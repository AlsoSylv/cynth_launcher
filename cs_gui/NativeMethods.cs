// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace CsBindgen
{
    public static unsafe partial class NativeMethods
    {
        const string __DllName = "csbindings";



        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "new_rust_state", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern State* new_rust_state(ushort* path, nuint len);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_version_manifest", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ManifestTaskWrapper* get_version_manifest(State* state);

        /// <summary># Safety # The task cannot be null, and has to be a manifest task. # The type cannot be checked by the Rust or C# compiler, and must instead be checked by the programmer.</summary>
        [DllImport(__DllName, EntryPoint = "poll_manifest_task", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_manifest_task(ManifestTaskWrapper* raw_task);

        /// <summary>This function consumes the task wrapper, dropping it, setting the manifest wrapper to a proper value And then return a NativeReturn, specifying if it's a success or error This is used to tell if this should be converted a C# exception  # Safety # The task wrapper cannot be Null # The manifest wrapper cannot be null</summary>
        [DllImport(__DllName, EntryPoint = "await_version_manifest", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_version_manifest(State* state, ManifestTaskWrapper* raw_task);

        /// <summary># Safety Task mut not be null Attempting to cancel a finished task should result in a panic</summary>
        [DllImport(__DllName, EntryPoint = "cancel_version_manifest", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void cancel_version_manifest(ManifestTaskWrapper* task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_latest_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern RefStringWrapper get_latest_release(State* state);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern RefStringWrapper get_name(State* state, nuint index);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_manifest_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint get_manifest_len(State* state);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "is_manifest_null", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool is_manifest_null(State* state);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ReleaseType get_type(State* state, nuint index);

        /// <summary># Safety # The owned string wrapper cannot have been mutated outside the rust code</summary>
        [DllImport(__DllName, EntryPoint = "free_owned_string_wrapper", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void free_owned_string_wrapper(OwnedStringWrapper string_wrapper);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_version_task", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* get_version_task(State* state, nuint index);

        /// <summary># Safety # The task cannot be null, and has to be a version task. # The type cannot be checked by the Rust or C# compiler, and must instead be checked by the programmer.</summary>
        [DllImport(__DllName, EntryPoint = "poll_version_task", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_version_task(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "await_version_task", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_version_task(State* state, TaskWrapper* raw_task);

        /// <summary># Safety This will drop a version task regardless of completion, this is only used when cancelling</summary>
        [DllImport(__DllName, EntryPoint = "cancel_version_task", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void cancel_version_task(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_asset_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* get_asset_index(State* state);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "poll_asset_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_asset_index(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "await_asset_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_asset_index(State* state, TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "cancel_asset_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void cancel_asset_index(TaskWrapper* raw_task);

        /// <summary># Safety Total and Finished will be treated like atomics</summary>
        [DllImport(__DllName, EntryPoint = "get_libraries", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* get_libraries(State* state, ulong* total, ulong* finished);

        [DllImport(__DllName, EntryPoint = "poll_libraries", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_libraries(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "await_libraries", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_libraries(State* state, TaskWrapper* raw_task);

        [DllImport(__DllName, EntryPoint = "cancel_libraries", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void cancel_libraries(TaskWrapper* raw_task);

        /// <summary># Safety # Total and Finished will be treated like atomics</summary>
        [DllImport(__DllName, EntryPoint = "get_assets", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* get_assets(State* state, ulong* total, ulong* finished);

        [DllImport(__DllName, EntryPoint = "poll_assets", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_assets(TaskWrapper* raw_task);

        [DllImport(__DllName, EntryPoint = "await_assets", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_assets(TaskWrapper* raw_task);

        [DllImport(__DllName, EntryPoint = "cancel_assets", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void cancel_assets(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_jar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* get_jar(State* state, ulong* total, ulong* finished);

        [DllImport(__DllName, EntryPoint = "poll_jar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_jar(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "await_jar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_jar(State* state, TaskWrapper* raw_task);

        [DllImport(__DllName, EntryPoint = "cancel_jar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void cancel_jar(TaskWrapper* raw_task);

        [DllImport(__DllName, EntryPoint = "play", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void play(State* state, LauncherData* data, nuint jvm_index, nuint acc_index);

        [DllImport(__DllName, EntryPoint = "play_default_jvm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void play_default_jvm(State* state, LauncherData* data, nuint acc_index);

        [DllImport(__DllName, EntryPoint = "get_device_response", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* get_device_response();

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "poll_device_response", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_device_response(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "await_device_response", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_device_response(State* state, TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_user_code", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern RefStringWrapper get_user_code(State* state);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_url", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern RefStringWrapper get_url(State* state);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "start_auth_loop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* start_auth_loop(State* state);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "poll_auth_loop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_auth_loop(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "await_auth_loop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_auth_loop(State* state, LauncherData* data, TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "cancel_auth_loop", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void cancel_auth_loop(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "try_refresh", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* try_refresh(LauncherData* data, nuint index);

        [DllImport(__DllName, EntryPoint = "poll_refresh", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_refresh(TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "await_refresh", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_refresh(State* state, LauncherData* data, TaskWrapper* raw_task);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "accounts_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint accounts_len(LauncherData* data);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "remove_account", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void remove_account(LauncherData* data, nuint index);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "get_account_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern RefStringWrapper get_account_name(LauncherData* data, nuint index);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "needs_refresh", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool needs_refresh(LauncherData* data, nuint index);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "jvm_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint jvm_len(LauncherData* data);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "jvm_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern RefStringWrapper jvm_name(LauncherData* data, nuint index);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "add_jvm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn add_jvm(LauncherData* data, ushort* ptr, nuint len);

        /// <summary># Safety</summary>
        [DllImport(__DllName, EntryPoint = "remove_jvm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void remove_jvm(LauncherData* data, nuint index);

        [DllImport(__DllName, EntryPoint = "read_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern TaskWrapper* read_data(State* state);

        [DllImport(__DllName, EntryPoint = "poll_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool poll_data(TaskWrapper* raw_task);

        /// <summary>If this is a success, we smuggle the pointer through the error</summary>
        [DllImport(__DllName, EntryPoint = "await_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeReturn await_data(TaskWrapper* raw_task);


    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct LauncherData
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct ManifestTaskWrapper
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct NativeReturn
    {
        public Code code;
        public OwnedStringWrapper error;
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct RefStringWrapper
    {
        public byte* char_ptr;
        public nuint len;
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct OwnedStringWrapper
    {
        public byte* char_ptr;
        public nuint len;
        public nuint capacity;
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct TaskWrapper
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct State
    {
    }


    public enum Code : uint
    {
        Success,
        RequestError,
        IOError,
        SerdeError,
        ProfileError,
        JvmError,
        TomlDe,
    }

    public enum ReleaseType : uint
    {
        OldAlpha,
        OldBeta,
        Release,
        Snapshot,
    }


}
    